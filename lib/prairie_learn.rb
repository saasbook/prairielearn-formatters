module PrairieLearn
  require 'json'
  require 'fileutils'

  autoload :Cucumber, 'prairie_learn/cucumber'
  autoload :Cucumber3, 'prairie_learn/cucumber3'
  # autoload :MiniTest, 'prairie_learn/minitest/unit'
  # autoload :RSpec, 'prairie_learn/rspec'
  autoload :RSpec3, 'prairie_learn/rspec3'
  # autoload :Spec, 'prairie_learn/spec'

  def cucumber3?
    defined?(::Cucumber) && ::Cucumber::VERSION >= '3'
  end
  module_function :cucumber3?

  # Cucumber detects the formatter API based on initialize arity
  if cucumber3?
    def initialize(config)
    end
  else
    def initialize(runtime, path_or_io, options)
    end
  end

  def rspec3?
    defined?(::RSpec::Core) && ::RSpec::Core::Version::STRING >= '3.0.0'
  end
  module_function :rspec3?

  if rspec3?
    # This needs to be run before `.new` is called, so putting it inside the
    # autoloaded rspec3 file will not work.
    ::RSpec::Core::Formatters.register(self,
    :example_started,           # collect points from example name
    :example_passed,            # when example passes, record points earned
    :example_failed,            # when example fails, capture error message
    :example_pending,           # when example pending... (TBD)
    #:example_group_started,
    #:example_group_finished,
    # :dump_summary,
    # :seed,
    # :message,
    # :example_group_finished,
    # :example_section_finished,
    :close)                     # when run is over, emit JSON
  end

  def self.new(*args)
    formatter = 
      case args.size
      when 0 then MiniTest::Unit
      when 1 then
        if args.first.class.to_s == "Cucumber::Configuration"
          Cucumber3
        elsif rspec3?
          RSpec3
        else
          RSpec
        end
      when 2 then Spec
      when 3
        Cucumber
      else
        raise ArgumentError
      end
    formatter.new(*args)
  end

  DEFAULT_PASS_MESSAGE = "OK"
  DEFAULT_FAIL_MESSAGE = "Failed"
  DEFAULT_UNEXECUTED_MESSAGE = "Pending/not executed"
  
  # @see https://prairielearn.readthedocs.io/en/latest/externalGrading/

  # Ruby representation of PL external grader's toplevel object in results/results.json
  TestReport = Struct.new(
    :gradable,                # default: true
    :score,                   # [0.0, 1.0]
    :message,                 # eg "Tests ran successfully"
    :output,                  # consolidated output from runner
    :tests,                   # array of TestCase structs
    keyword_init: true)
  # Ruby representation of one element of the 'tests' array in the above toplevel object
  TestCase = Struct.new(
    :name,                    # "Test N"
    :description,             # rspec docstring
    :points,                  # any scalar
    :max_points,              # any scalar; in practice, same as points
    :output,                  # any messages generated by test case (eg if failed expectation)
    :message,                 # optional: helpful hint for student
    keyword_init: true)

  def self.finalize_and_jsonify(test_report)
    test_report.score =
      (denominator = test_report.tests.sum { |t| t.max_points }).zero? ?
        0.0 :
        test_report.tests.sum { |t| t.points } / denominator.to_f
    test_report.tests.map!(&:to_h)
    JSON.pretty_generate(test_report.to_h)
  end

end
